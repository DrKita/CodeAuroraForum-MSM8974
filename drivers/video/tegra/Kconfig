if ARCH_TEGRA

config TEGRA_NVMAP
	bool "Tegra GPU memory management driver (nvmap)"
	select ARM_DMA_USE_IOMMU if IOMMU_API
	select DMA_SHARED_BUFFER
	default y
	help
	  Say Y here to include the memory management driver for the Tegra
	  GPU, multimedia and display subsystems

config NVMAP_HIGHMEM_ONLY
	bool "Use only HIGHMEM for nvmap"
	depends on TEGRA_NVMAP && IOMMU_API && HIGHMEM
	default n
	help
	  Say Y here to restrict nvmap system memory allocations (both
	  physical system memory and IOVMM) to just HIGHMEM pages.

config NVMAP_CARVEOUT_KILLER
	bool "Reclaim nvmap carveout by killing processes"
	depends on TEGRA_NVMAP
	default n
	help
	  Say Y here to allow the system to reclaim carveout space by killing
	  processes. This will kill the largest consumers of lowest priority
	  first.

config NVMAP_PAGE_POOLS
	bool "Use page pools to reduce allocation overhead"
	depends on TEGRA_NVMAP
	default y
	help
	  say Y here to reduce the alloction overhead, which is significant
	  for uncached, writecombine and inner cacheable memories as it
	  involves changing page attributes during every allocation per page
	  and flushing cache. Alloc time is reduced by allcoating the pages
	  ahead and keeping them aside. The reserved pages would be released
	  when system is low on memory and acquired back during release of
	  memory.

config NVMAP_PAGE_POOLS_INIT_FILLUP
	bool "Fill up page pools during page pools init"
	depends on NVMAP_PAGE_POOLS
	default y
	help
	  Say Y here to fill up the page pools during page pool init time.
	  This helps in faster alloctions right from the early alloction
	  requests. Page pools fill up during init would increase the boot time.
	  If increase in boot time is not acceptable, keep this option disabled.

config NVMAP_PAGE_POOLS_INIT_FILLUP_SIZE
	depends on NVMAP_PAGE_POOLS_INIT_FILLUP
	hex "Amount of memory to fill up page pools with during bootup in MB"
	default 0x64

config NVMAP_PAGE_POOL_SIZE
	depends on NVMAP_PAGE_POOLS
	hex "Page pool size in pages"
	default 0x0

config NVMAP_CACHE_MAINT_BY_SET_WAYS
	bool "Enable cache maintenance by set/ways"
	depends on TEGRA_NVMAP
	help
	 Say Y here to reduce cache maintenance overhead by MVA.
	 This helps in reducing cache maintenance overhead in the systems,
	 where inner cache includes only L1. For the systems, where inner cache
	 includes L1 and L2, keep this option disabled.

config NVMAP_CACHE_MAINT_BY_SET_WAYS_ON_ONE_CPU
	bool "Perform cache maint on one cpu only"
	depends on TEGRA_NVMAP && NVMAP_CACHE_MAINT_BY_SET_WAYS
	help
	  Say Y here to avoid cache maint on all CPU's during inner cache maint
	  by set/ways. When L1 and L2 are inner caches, cache maint on one
	  CPU is enough. When L1 is inner and L2 is outer, cache maint on
	  all CPU's is necessary during L1 cache maint by set/ways.

config NVMAP_OUTER_CACHE_MAINT_BY_SET_WAYS
	bool "Enable outer cache maintenance by set/ways"
	depends on TEGRA_NVMAP
	help
	  Say Y here if you want to optimize cache maintenance for ranges
	  bigger than size of outer cache. This option has no effect on
	  system without outer cache.

config NVMAP_DEFERRED_CACHE_MAINT
	bool "Enable deferred cache maintenance"
	depends on TEGRA_NVMAP
	help
	  Say Y here if you want to defer flush requests for
	  nvmap memory buffer. Cache maintenance of deferred requests
	  is more efficient since there is a high chance that cache lines
	  of earlier requests are already flushed. Also, if total size of
	  deferred ranges is big enough, we flush whole inner or outer
	  cache.

config NVMAP_DMABUF_STASH
	bool "Enable stashing of IOVA maps with dmabuf"
	depends on TEGRA_NVMAP
	default y
	help
	  Set to Y if you would like nvmap to stash maps when using dma
	  bufs. This will speed up remapping of the same handle at the cost
	  of using more IOVA space.

config NVMAP_DMABUF_STASH_STATS
	bool "Enable stat tracking on the stash"
	depends on NVMAP_DMABUF_STASH
	help
	  Say Y to enable tracking of basic cache statistics on the dmabuf
	  stash. This adds some overhead but should be very useful for
	  debugging memory leaks.

config NVMAP_VPR
	bool "Enable VPR Heap."
	depends on TEGRA_NVMAP
	default n
	help
	  Say Y here to enable Video Protection Region(VPR) heap.
	  if unsure, say N.

config NVMAP_FORCE_ZEROED_USER_PAGES
	bool "Only alloc zeroed pages for user space"
	depends on TEGRA_NVMAP
	help
	  Say Y here to force zeroing of pages allocated for user space. This
	  avoids leaking kernel secure data to user space. This can add
	  significant overhead to allocation operations depending on the
	  allocation size requested.

config NVMAP_USE_FD_FOR_HANDLE
	bool "Use Fd's to represent NvMap handles"
	depends on TEGRA_NVMAP
	default y
	help
	  Say Y here to use Fd's for representing NvMap handles
	  in user space. Enabling this config returns DmaBuf
	  compatible Fd's to user space during handle creation
	  requests. The kernel component that receives these Fd's
	  can use either NvMap interface or DmaBuf interface in order
	  to access NvMap handle memory.

config NVMAP_USE_CMA_FOR_CARVEOUT
	bool "Use CMA memory for carveouts"
	depends on TEGRA_NVMAP
	help
	  Say Y here to reserve carveout memory using CMA
	  API. CMA reserved memory can be used by applications
	  when it is not in use by the device that reserved it.

config NVMAP_CPA
	bool "Use CPA API in nvmap"
	depends on CPA
	help
	  Say Y here to have nvmap use CPA. CPA is necessary for
	  certain chips where page table aliasing can cause undefined
	  results due to speculative memory loads/stores. If unsure,
	  say N.

config NVMAP_CONVERT_CARVEOUT_TO_IOVMM
	bool "Convert carveout to IOVMM"
	depends on TEGRA_NVMAP && IOMMU_API
	default y
	help
	  Say Y here to force to convert carveout memory requests to
	  I/O virtual memory requests.

config NVMAP_HANDLE_MARSHAL
	bool "Marshal nvmap handle id"
	depends on TEGRA_NVMAP
	help
	  Enables nvmap handle id marshalling. Marshalling converts
	  the nvmap handle id into an unique number before passing
	  the handle id to user/kernel clients. The marshalling
	  would allow sharing a 64-bit handle id as 32-bit id to
	  user space when kernel is 64-bit and user space is 32-bit.

endif
