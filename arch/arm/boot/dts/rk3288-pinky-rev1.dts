/*
 * Google Veyron Pinky Rev 1 board device tree source
 *
 * Copyright 2014 Google, Inc
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

/dts-v1/;
#include "rk3288.dtsi"

/ {
	compatible = "google,veyron-pinky-rev1", "google,veyron-pinky",
		     "google,veyron", "rockchip,rk3288";

	memory {
		reg = <0x0 0x80000000>;
	};

	gpio-keys {
		compatible = "gpio-keys";
		#address-cells = <1>;
		#size-cells = <0>;
		autorepeat;

		pinctrl-names = "default";
		pinctrl-0 = <&pwrbtn>;

		button@0 {
			gpios = <&gpio0 5 GPIO_ACTIVE_LOW>;
			linux,code = <116>;
			label = "GPIO Key Power";
			linux,input-type = <1>;
			gpio-key,wakeup = <1>;
			debounce-interval = <100>;
		};
	};

	/* This turns on vbus for host1 (dwc2) */
	vcc5_host1: vcc5-host1-regulator {
		compatible = "regulator-fixed";
		enable-active-high;
		gpio = <&gpio0 11 GPIO_ACTIVE_HIGH>;
		pinctrl-names = "default";
		pinctrl-0 = <&usb1_pwr_en>;
		regulator-name = "vcc5_host1";
		regulator-always-on;
		regulator-boot-on;
	};

	/* This turns on vbus for otg for host mode (dwc2) */
	vcc5_host2: vcc5-host2-regulator {
		compatible = "regulator-fixed";
		enable-active-high;
		gpio = <&gpio0 12 GPIO_ACTIVE_HIGH>;
		pinctrl-names = "default";
		pinctrl-0 = <&usb2_pwr_en>;
		regulator-name = "vcc5_host2";
		regulator-always-on;
		regulator-boot-on;
	};
};

&emmc {
	broken-cd;
	bus-width = <8>;
	cap-mmc-highspeed;
	disable-wp;
	non-removable;
	num-slots = <1>;
	pinctrl-names = "default";
	pinctrl-0 = <&emmc_clk &emmc_cmd &emmc_pwr &emmc_bus8>;
	status = "okay";
};

&sdmmc {
        /* This is 1 because we get errors with width 4 at 25Mhz */
	bus-width = <1>;
	cap-mmc-highspeed;
	cap-sd-highspeed;
	card-detect-delay = <200>;
	cd-gpios = <&gpio7 5 GPIO_ACTIVE_LOW>;
	num-slots = <1>;
	pinctrl-names = "default";
	/*
	 * We seem to need to configure the default card detect pin to be
	 * pulled-up even though we are not using that line, otherwise we
	 * get a hang, hence the use of both sdmmc_cd and sdmmc_cd_gpio.
	 */
	pinctrl-0 = <&sdmmc_clk &sdmmc_cmd &sdmmc_cd &sdmmc_cd_gpio
		     &sdmmc_wp_gpio &sdmmc_bus4>;
	status = "okay";
	wp-gpios = <&gpio7 10 GPIO_ACTIVE_LOW>;
};

&i2c0 {
	status = "okay";
};

&i2c1 {
	status = "okay";
};

&i2c2 {
	status = "okay";
};

&i2c3 {
	status = "okay";
};

&i2c4 {
	status = "okay";
};

&i2c5 {
	status = "okay";
};

&wdt {
	status = "okay";
};

&uart0 {
	status = "okay";
};

&uart1 {
	status = "okay";
};

&uart2 {
	status = "okay";
};

&pinctrl {
	buttons {
		pwrbtn: pwrbtn {
			rockchip,pins = <0 5 RK_FUNC_GPIO &pcfg_pull_up>;
		};
	};

	sdmmc {
		sdmmc_cd_gpio: sdmmc-cd-gpio {
			rockchip,pins = <7 5 RK_FUNC_GPIO &pcfg_pull_up>;
		};

		sdmmc_wp_gpio: sdmmc-wp-gpio {
			rockchip,pins = <7 10 RK_FUNC_GPIO &pcfg_pull_up>;
		};
	};

	usb-host {
		usb1_pwr_en: usb1-pwr-en {
			rockchip,pins = <0 11 RK_FUNC_GPIO &pcfg_pull_none>;
		};

		usb2_pwr_en: usb2-pwr-en {
			rockchip,pins = <0 12 RK_FUNC_GPIO &pcfg_pull_none>;
		};
	};
};

&usb_host0_ehci {
	status = "okay";
};

&usb_host1 {
	status = "okay";
};

&usb_otg {
	dr_mode = "host";
	status = "okay";
};
